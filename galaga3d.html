<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Galaga 3D — Single-file library + demo</title>
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    #app{width:100%;height:100%;display:flex;flex-direction:column}
    #canvas-wrap{flex:1;position:relative}
    canvas{display:block;width:100%;height:100%}
    #hud{position:absolute;left:12px;top:12px;z-index:3}
    .btn{background:#111;border:1px solid #444;padding:6px 10px;color:#fff;border-radius:6px;margin-right:6px;cursor:pointer}
    #footer{padding:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0));}
    a{color:#7dd3fc}
    #score{font-weight:700}
  </style>
</head>
<body>
<div id="app">
  <div id="canvas-wrap">
    <div id="hud">
      <button id="start" class="btn">Start</button>
      <button id="pause" class="btn">Pause</button>
      <button id="reset" class="btn">Reset</button>
      <span id="score">Score: 0</span>
    </div>
  </div>
  <div id="footer">Use arrow keys to move, space to shoot. This is a single-file library + demo. API: window.Galaga3D</div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
// Galaga3D — single-file library + demo
// Small, dependency-light wrapper around THREE to provide a simple Galaga-like experience.
// Exposes window.Galaga3D class. Instantiate with new Galaga3D(containerElement, options)

(function(global){
  const THREE = global.THREE;
  if(!THREE) throw new Error('Three.js is required. This file expects THREE on window.');

  class Galaga3D {
    constructor(container, opts={}){
      this.container = (typeof container === 'string') ? document.querySelector(container) : (container || document.body);
      this.opts = Object.assign({width:0,height:0}, opts);
      this.score = 0;
      this.running = false;
      this._init();
    }

    _init(){
      // renderer
      this.renderer = new THREE.WebGLRenderer({antialias:true});
      this.renderer.setPixelRatio(window.devicePixelRatio || 1);
      this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
      this.container.appendChild(this.renderer.domElement);

      // scene
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x000000);

      // camera
      const aspect = this.container.clientWidth / Math.max(1,this.container.clientHeight);
      this.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
      this.camera.position.set(0, 8, 18);

      // lights
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5,10,7);
      this.scene.add(dir);
      this.scene.add(new THREE.AmbientLight(0x888888));

      // player
      this.player = this._makePlayer();
      this.player.position.set(0,0,0);
      this.scene.add(this.player);

      // enemies container
      this.enemies = new THREE.Group();
      this.scene.add(this.enemies);

      // bullets
      this.bullets = [];
      this.enemyBullets = [];

      // starfield
      this._makeStarfield()

      // state
      this.playerVelocity = new THREE.Vector3();
      this.keys = {};
      this.lastShot = 0;
      this.spawnEnemies();

      // event handlers
      this._onResize = this._onResize.bind(this);
      this._onKey = this._onKey.bind(this);
      window.addEventListener('resize', this._onResize);
      window.addEventListener('keydown', e=>this._onKey(e,true));
      window.addEventListener('keyup', e=>this._onKey(e,false));

      // loop
      this._tick = this._tick.bind(this);
      this._lastTime = performance.now();

      // simple API hooks
      this.onScore = this.opts.onScore || function(){};
    }

    _makeStarfield(){
      const stars = new THREE.BufferGeometry();
      const count = 400;
      const positions = new Float32Array(count*3);
      for(let i=0;i<count;i++){
        positions[i*3+0] = (Math.random()-0.5)*80;
        positions[i*3+1] = (Math.random()-0.5)*40;
        positions[i*3+2] = -Math.random()*200;
      }
      stars.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const material = new THREE.PointsMaterial({color:0xffffff,size:0.6,transparent:true,opacity:0.9});
      const p = new THREE.Points(stars, material);
      this.scene.add(p);
    }

    _makePlayer(){
      const g = new THREE.ConeGeometry(0.6,1.6,3);
      g.rotateX(Math.PI/2);
      const m = new THREE.MeshStandardMaterial({color:0x00c2ff,metalness:0.2,roughness:0.6});
      const mesh = new THREE.Mesh(g,m);
      mesh.name = 'player';
      mesh.userData.radius = 1.0;
      return mesh;
    }

    spawnEnemies(){
      // clear
      while(this.enemies.children.length) this.enemies.remove(this.enemies.children[0]);
      this.enemyList = [];
      const rows = 3; const cols = 8;
      const spacingX = 2.6; const spacingY = 1.6;
      const startX = -((cols-1)/2)*spacingX;
      const startY = 6;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const e = this._makeEnemy();
          e.position.set(startX + c*spacingX, startY - r*spacingY, -10 - r*2);
          e.userData.hit = false;
          this.enemies.add(e);
          this.enemyList.push(e);
        }
      }
      // simple horizontal sweep
      this.enemySweep = {dir:1,limit:12,speed:0.02};
    }

    _makeEnemy(){
      const g = new THREE.BoxGeometry(1,1,1);
      const m = new THREE.MeshStandardMaterial({color:0xff7ab6,metalness:0.1,roughness:0.6});
      const mesh = new THREE.Mesh(g,m);
      mesh.userData.radius = 0.85;
      return mesh;
    }

    _onKey(e,down){
      if(e.code==='Space'){ e.preventDefault(); }
      this.keys[e.code] = down;
    }

    _onResize(){
      const w = this.container.clientWidth; const h = this.container.clientHeight;
      this.camera.aspect = Math.max(0.1,w/h);
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(w,h);
    }

    start(){
      if(this.running) return;
      this.running = true;
      this._lastTime = performance.now();
      this._tick();
    }
    pause(){ this.running = false; }
    reset(){ this.score = 0; this.onScore(this.score); this.spawnEnemies(); }

    _tick(){
      if(!this.running) return;
      const now = performance.now();
      const dt = Math.min(40,(now - this._lastTime));
      this._lastTime = now;

      this._update(dt/16);
      this.renderer.render(this.scene, this.camera);
      requestAnimationFrame(this._tick);
    }

    _update(dt){
      // player movement
      const speed = 0.2*dt;
      if(this.keys['ArrowLeft']) this.player.position.x -= speed;
      if(this.keys['ArrowRight']) this.player.position.x += speed;
      if(this.keys['ArrowUp']) this.player.position.y += speed*0.6;
      if(this.keys['ArrowDown']) this.player.position.y -= speed*0.6;
      // clamp
      this.player.position.x = THREE.MathUtils.clamp(this.player.position.x, -8, 8);
      this.player.position.y = THREE.MathUtils.clamp(this.player.position.y, -3, 8);

      // shooting
      if(this.keys['Space']){
        if(performance.now() - this.lastShot > 220){ this.shoot(); this.lastShot = performance.now(); }
      }

      // bullets
      for(let i=this.bullets.length-1;i>=0;i--){
        const b = this.bullets[i];
        b.position.addScaledVector(b.userData.vel, dt*0.5);
        if(b.position.z < -200) { this._removeBullet(b); continue; }
        // check collisions with enemies
        for(let j=this.enemyList.length-1;j>=0;j--){
          const e = this.enemyList[j];
          if(!e || e.userData.hit) continue;
          const d = b.position.distanceTo(e.position);
          if(d < (b.userData.radius + e.userData.radius)){
            e.userData.hit = true; this.scene.remove(e); this.enemyList.splice(j,1);
            this._removeBullet(b);
            this._addScore(100);
            break;
          }
        }
      }

      // enemy sweep
      const sweep = this.enemySweep;
      sweep.offset = (sweep.offset || 0) + sweep.dir * sweep.speed * dt;
      if(Math.abs(sweep.offset) > sweep.limit){ sweep.dir *= -1; }
      this.enemies.position.x = sweep.offset;

      // check win condition
      if(this.enemyList.length === 0){ this.spawnEnemies(); }
    }

    shoot(){
      const b = new THREE.Mesh(new THREE.SphereGeometry(0.18,8,8), new THREE.MeshBasicMaterial({color:0xffff66}));
      b.position.copy(this.player.position).add(new THREE.Vector3(0,0,-2));
      b.userData = {vel: new THREE.Vector3(0,0,-0.9), radius:0.18};
      this.scene.add(b); this.bullets.push(b);
    }

    _removeBullet(b){
      const idx = this.bullets.indexOf(b);
      if(idx>=0) this.bullets.splice(idx,1);
      this.scene.remove(b);
    }

    _addScore(n){ this.score += n; this.onScore(this.score); }

    dispose(){
      this.pause();
      window.removeEventListener('resize', this._onResize);
      window.removeEventListener('keydown', this._onKey);
      window.removeEventListener('keyup', this._onKey);
      if(this.renderer && this.renderer.domElement && this.renderer.domElement.parentNode) this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
    }
  }

  // expose
  global.Galaga3D = Galaga3D;

})(window);

// Auto-demo wiring
(function(){
  const wrap = document.getElementById('canvas-wrap');
  const app = new Galaga3D(wrap);
  // hook up hud
  const scoreEl = document.getElementById('score');
  app.onScore = s => { scoreEl.textContent = 'Score: ' + s; };
  document.getElementById('start').addEventListener('click', ()=>app.start());
  document.getElementById('pause').addEventListener('click', ()=>app.pause());
  document.getElementById('reset').addEventListener('click', ()=>{ app.reset(); });
  // start automatically
  app.start();
})();
</script>
</body>
</html>
